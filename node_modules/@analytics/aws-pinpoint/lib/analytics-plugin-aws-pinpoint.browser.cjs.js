'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var deepmerge = _interopDefault(require('deepmerge'));
var analyticsUtils = require('analytics-utils');
var aws4fetch = require('aws4fetch');
var analyticsPluginTabEvents = require('analytics-plugin-tab-events');

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function browserClientInfo() {
  if (typeof window === 'undefined') {
    return {};
  }

  if (!window.navigator) {
    return {};
  }

  var _window$navigator = window.navigator,
      platform = _window$navigator.platform,
      product = _window$navigator.product,
      vendor = _window$navigator.vendor,
      userAgent = _window$navigator.userAgent;
  var type = browserType(userAgent);
  return {
    platform: platform,
    make: vendor || product,
    model: type.type,
    version: type.version,
    appVersion: [type.type, type.version].join('/'),
    language: getLanguage(),
    timezone: browserTimezone()
  };
}

function getLanguage() {
  var _window$navigator2 = window.navigator,
      language = _window$navigator2.language,
      browserLanguage = _window$navigator2.browserLanguage,
      languages = _window$navigator2.languages;
  return (language || browserLanguage || (languages || ['en_US'])[0]).toLowerCase().replace('-', '_');
}

function browserTimezone() {
  var tzMatch = /\(([A-Za-z\s].*)\)/.exec(new Date().toString());
  return tzMatch ? tzMatch[1] || '' : '';
}

function browserType(userAgent) {
  var operaMatch = /.+(Opera[\s[A-Z]*|OPR[\sA-Z]*)\/([0-9\.]+).*/i.exec(userAgent);

  if (operaMatch) {
    return {
      type: operaMatch[1],
      version: operaMatch[2]
    };
  }

  var ieMatch = /.+(Trident|Edge)\/([0-9\.]+).*/i.exec(userAgent);

  if (ieMatch) {
    return {
      type: ieMatch[1],
      version: ieMatch[2]
    };
  }

  var cfMatch = /.+(Chrome|Firefox|FxiOS)\/([0-9\.]+).*/i.exec(userAgent);

  if (cfMatch) {
    return {
      type: cfMatch[1],
      version: cfMatch[2]
    };
  }

  var sMatch = /.+(Safari)\/([0-9\.]+).*/i.exec(userAgent);

  if (sMatch) {
    return {
      type: sMatch[1],
      version: sMatch[2]
    };
  }

  var awkMatch = /.+(AppleWebKit)\/([0-9\.]+).*/i.exec(userAgent);

  if (awkMatch) {
    return {
      type: awkMatch[1],
      version: awkMatch[2]
    };
  }

  var anyMatch = /.*([A-Z]+)\/([0-9\.]+).*/i.exec(userAgent);

  if (anyMatch) {
    return {
      type: anyMatch[1],
      version: anyMatch[2]
    };
  }

  return {
    type: '',
    version: ''
  };
}

function getEventName(key) {
  var eventMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return eventMap[key] || key;
}

var ALLOWED_CHANNELS = ['PUSH', 'GCM', 'APNS', 'APNS_SANDBOX', 'APNS_VOIP', 'APNS_VOIP_SANDBOX', 'ADM', 'SMS', 'VOICE', 'EMAIL', 'BAIDU', 'CUSTOM'];
var CHANNEL_TYPES = ALLOWED_CHANNELS.reduce(function (acc, curr) {
  acc[curr] = curr;
  return acc;
}, {});

/* The endpoint began a new session. */
var SESSION_START = '_session.start';
/* The endpoint ended a session. */

var SESSION_STOP = '_session.stop';
/* The endpoint paused a session. Paused sessions can be resumed so that you can continue to collect metrics without starting an entirely new session. */

var SESSION_PAUSE = '_session.pause';
/* The endpoint resumed a session. */

var SESSION_RESUME = '_session.resume';
/* The endpoint logged in to your app. */

var AUTH_SIGN_IN = '_userauth.sign_in';
/* A new endpoint completed the registration process in your app. */

var AUTH_SIGN_UP = '_userauth.sign_up';
/* The endpoint attempted to sign in to your app, but wasn't able to complete the process. */

var AUTH_FAIL = '_userauth.auth_fail';
/* The endpoint made a purchase in your app. */

var ECOM_PURCHASE = '_monetization.purchase';
/* The pageview event */

var PAGE_VIEW = 'pageView';

var events = /*#__PURE__*/Object.freeze({
  SESSION_START: SESSION_START,
  SESSION_STOP: SESSION_STOP,
  SESSION_PAUSE: SESSION_PAUSE,
  SESSION_RESUME: SESSION_RESUME,
  AUTH_SIGN_IN: AUTH_SIGN_IN,
  AUTH_SIGN_UP: AUTH_SIGN_UP,
  AUTH_FAIL: AUTH_FAIL,
  ECOM_PURCHASE: ECOM_PURCHASE,
  PAGE_VIEW: PAGE_VIEW
});

var inBrowser = typeof window !== 'undefined';

// import 'navigator.sendbeacon'

var BEACON_SUPPORTED = typeof navigator !== 'undefined' && navigator && typeof navigator.sendBeacon === 'function';
var ENDPOINT_KEY = '__endpoint';
var RETRYABLE_CODES = [429, 500];
var ACCEPTED_CODES = [202];
var BAD_REQUEST_CODE = 400;
var clientInfo = browserClientInfo(); // TODO localize queue

var EVENTS_QUEUE = [];

function noOp() {
  return {};
}

var EMAIL_REGEX = /.+\@.+\..+/;

function isEmail(string) {
  return EMAIL_REGEX.test(string);
}
function initialize() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // @TODO clean up 
  var configuration = _objectSpread2({
    getContext: config.getContext || noOp,
    enrichEventAttributes: config.enrichEventAttributes || noOp,
    enrichEventMetrics: config.enrichEventMetrics || noOp,
    credentials: config.credentials || {},
    getEndpointId: config.getEndpointId
  }, config); // Create function that sends to pinpoint


  var sentDataToPinpoint = createSendEvents(configuration); // Create instance of record

  var recordEvent = makeRecordFunction(_objectSpread2({
    sentDataToPinpoint: sentDataToPinpoint
  }, configuration)); // Run initialize endpoint merge

  mergeEndpointData({}, config); // Flush remaining events on page close

  var detachWindowUnloadListener = onWindowUnload(recordEvent); // Function to detach listeners

  return {
    updateEndpoint: sentDataToPinpoint,
    recordEvent: recordEvent,
    disable: function disable() {
      detachWindowUnloadListener();
    }
  };
}

function onWindowUnload(recordFunc) {
  if (!inBrowser) {
    return noOp;
  }

  var stopSessionHandler = stopSessionFactory(recordFunc);
  window.addEventListener('beforeunload', stopSessionHandler);
  return function () {
    return window.removeEventListener('beforeunload', stopSessionHandler);
  };
}

function stopSessionFactory(recordFunc) {
  // Flush remaining events
  return function () {
    console.log('Fire stop session');
    recordFunc(SESSION_STOP, false);
  };
}

function getStorageKey(id) {
  return "".concat(ENDPOINT_KEY, ".").concat(id);
}

function getEndpoint(id) {
  var endpointInfo = {};

  try {
    endpointInfo = JSON.parse(localStorage.getItem(getStorageKey(id))) || {};
  } catch (error) {}

  return endpointInfo;
}

function setEndpoint(id, endpointData) {
  var endpointKey = getStorageKey(id);
  var data = typeof endpointData === 'string' ? endpointData : JSON.stringify(endpointData);
  localStorage.setItem(endpointKey, data);
}

function makeRecordFunction() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var timer;
  var sentDataToPinpoint = config.sentDataToPinpoint;
  return (
    /*#__PURE__*/
    function () {
      var _recordEvent = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(eventName) {
        var data,
            endpoint,
            queue,
            eventPayload,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                data = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                endpoint = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                queue = _args.length > 3 && _args[3] !== undefined ? _args[3] : true;

                if (typeof data === 'boolean') {
                  queue = data;
                  data = {};
                }

                if (typeof endpoint === 'boolean') {
                  queue = endpoint;
                  endpoint = {};
                }

                _context.next = 7;
                return formatEvent(eventName, data, config);

              case 7:
                eventPayload = _context.sent;

                if (!(Object.entries(endpoint).length || eventName === PAGE_VIEW)) {
                  _context.next = 12;
                  break;
                }

                _context.next = 11;
                return mergeEndpointData(endpoint, config);

              case 11:
                endpoint = _context.sent;

              case 12:
                // Store sent events to queue
                EVENTS_QUEUE.push(eventPayload); // If config setting to send every event as it happens

                {
                  _context.next = 15;
                  break;
                }

                return _context.abrupt("return", sentDataToPinpoint());

              case 15:
                if (queue) {
                  _context.next = 17;
                  break;
                }

                return _context.abrupt("return", sentDataToPinpoint());

              case 17:
                if (timer) {
                  clearTimeout(timer);
                } // Flush new events after 3 seconds.


                timer = setTimeout(sentDataToPinpoint, 3000);

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function recordEvent(_x) {
        return _recordEvent.apply(this, arguments);
      }

      return recordEvent;
    }()
  );
}

function createSendEvents() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getEndpointId = config.getEndpointId,
      debug = config.debug;
  return (
    /*#__PURE__*/
    function () {
      var _sentDataToPinpoint = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var endpoint,
            endpointData,
            endpointId,
            channelType,
            Events,
            Endpoint,
            eventsRequest,
            data,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                endpoint = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};

                if (!(!EVENTS_QUEUE.length && !Object.keys(endpoint).length)) {
                  _context2.next = 4;
                  break;
                }

                if (debug) console.log('No events, return early');
                return _context2.abrupt("return");

              case 4:
                // console.log('aws', aws)
                endpointData = endpoint; // Events are associated with an endpoint.

                _context2.next = 7;
                return getEndpointId();

              case 7:
                endpointId = _context2.sent;

                if (debug) {
                  console.log('resolved endpointId', endpointId);
                }

                if (endpointId) {
                  _context2.next = 12;
                  break;
                }

                console.error('No User ID found. Call Auth()');
                return _context2.abrupt("return");

              case 12:
                if (!Object.entries(endpoint).length) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 15;
                return mergeEndpointData(endpoint, config);

              case 15:
                endpointData = _context2.sent;
                _context2.next = 19;
                break;

              case 18:
                endpointData = getEndpoint(endpointId) || {};

              case 19:
                if (debug) {
                  console.log('endpointData', endpointData);
                }

                channelType = endpointData.ChannelType; // If email is set, set email channel

                if (endpointData.Address && isEmail(endpointData.Address)) {
                  channelType = CHANNEL_TYPES.EMAIL;
                }

                if (!channelType && endpointData.Address) {
                  if (clientInfo.platform === 'android') {
                    channelType = channelType || CHANNEL_TYPES.GCM;
                  } else {
                    channelType = channelType || CHANNEL_TYPES.APNS;
                  }
                }

                if (debug) {
                  console.log('CHANNEL_TYPE', channelType);
                } // Reduce events to an object keyed by event ID.


                Events = EVENTS_QUEUE.reduce(function (acc, event) {
                  return _objectSpread2({}, event, {}, acc);
                }, {});
                /*
                console.log('────────sentDataToPinpoint───────────')
                console.log(Events)
                console.log('───────End sentDataToPinpoint────────')
                /**/
                // Build endpoint data.

                Endpoint = endpointData;
                Endpoint.RequestId = analyticsUtils.uuid();
                Endpoint.ChannelType = channelType;

                if (Endpoint.Address) {
                  // https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-endpoints.html#apps-application-id-endpoints-properties
                  // Default OptOut is ALL
                  // OptOut: 'NONE',
                  Endpoint.OptOut = endpointData.OptOut || 'NONE';
                } // const endpointId = endpointId.replace(`${COGNITO_REGION}:`, '' )
                // Build events request object.


                eventsRequest = formatPinpointBody(endpointId, Endpoint, Events);
                _context2.prev = 30;
                _context2.next = 33;
                return callAWS(eventsRequest, config);

              case 33:
                data = _context2.sent;
                _context2.next = 39;
                break;

              case 36:
                _context2.prev = 36;
                _context2.t0 = _context2["catch"](30);
                console.log('callPinPoint err', _context2.t0);

              case 39:
                // console.log('Before', EVENTS_QUEUE)

                /* Purge queue */
                EVENTS_QUEUE = []; // console.log('After', EVENTS_QUEUE)

                return _context2.abrupt("return", endpointData);

              case 41:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[30, 36]]);
      }));

      function sentDataToPinpoint() {
        return _sentDataToPinpoint.apply(this, arguments);
      }

      return sentDataToPinpoint;
    }()
  );
}

function formatPinpointBody(endpointId, endpoint, events) {
  return {
    BatchItem: _defineProperty({}, endpointId, {
      Endpoint: endpoint,
      Events: events
    })
  };
}

function formatEvent(_x2) {
  return _formatEvent.apply(this, arguments);
}

function _formatEvent() {
  _formatEvent = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3(eventName) {
    var data,
        config,
        appTitle,
        appPackageName,
        appVersionCode,
        eventMapping,
        getSessionID,
        enrichEventAttributes,
        enrichEventMetrics,
        debug,
        type,
        contextInfo,
        pageSession,
        subSessionId,
        subSessionStart,
        elapsed,
        userDefinedAttributes,
        eventId,
        time,
        timeStamp,
        sessionId,
        defaultEventAttributes,
        extraAttributes,
        eventAttributes,
        elapsedSessionTime,
        userDefinedMetrics,
        defaultMetrics,
        extraMetrics,
        eventMetrics,
        preparedData,
        eventPayload,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            data = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
            config = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
            appTitle = config.appTitle, appPackageName = config.appPackageName, appVersionCode = config.appVersionCode, eventMapping = config.eventMapping, getSessionID = config.getSessionID, enrichEventAttributes = config.enrichEventAttributes, enrichEventMetrics = config.enrichEventMetrics, debug = config.debug;
            type = getEventName(eventName, eventMapping);
            contextInfo = grabContext(config); // console.log('contextInfo', contextInfo)

            pageSession = contextInfo.pageSession, subSessionId = contextInfo.subSessionId, subSessionStart = contextInfo.subSessionStart, elapsed = contextInfo.elapsed;
            userDefinedAttributes = data.attributes || {};
            eventId = data.eventId || analyticsUtils.uuid();
            time = data.time ? new Date(data.time) : new Date();
            timeStamp = time.toISOString();
            sessionId = data.sessionId || getSessionID();
            defaultEventAttributes = {
              date: timeStamp,
              session: sessionId,
              pageSession: pageSession
            };
            _context3.next = 14;
            return enrichEventAttributes();

          case 14:
            extraAttributes = _context3.sent;

            /* Format attributes */
            eventAttributes = _objectSpread2({}, defaultEventAttributes, {}, extraAttributes, {}, userDefinedAttributes);
            /* Format metrics */

            elapsedSessionTime = elapsed + (time.getTime() - subSessionStart);
            userDefinedMetrics = data.metrics || {};
            defaultMetrics = {
              /* Time of session */
              sessionTime: elapsedSessionTime,

              /* Date metrics */
              hour: time.getHours(),
              day: time.getDay() + 1,
              month: time.getMonth() + 1,
              year: time.getFullYear()
            };
            _context3.next = 21;
            return enrichEventMetrics();

          case 21:
            extraMetrics = _context3.sent;
            eventMetrics = _objectSpread2({}, defaultMetrics, {}, extraMetrics, {}, userDefinedMetrics);
            _context3.next = 25;
            return prepareAttributes(eventAttributes);

          case 25:
            _context3.t0 = _context3.sent;
            _context3.next = 28;
            return prepareMetrics(eventMetrics);

          case 28:
            _context3.t1 = _context3.sent;
            preparedData = {
              attributes: _context3.t0,
              metrics: _context3.t1
            };

            if (debug) {
              console.log("".concat(eventId, ":").concat(type));
              console.log('eventAttributes', preparedData.attributes);
              console.log('eventMetrics', preparedData.metrics);
            } // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Pinpoint.html#putEvents-property


            eventPayload = _defineProperty({}, eventId, {
              EventType: type,
              Timestamp: timeStamp,
              AppPackageName: appPackageName,
              AppTitle: appTitle,
              AppVersionCode: appVersionCode,

              /* Event attributes */
              Attributes: preparedData.attributes,

              /* Event metrics */
              Metrics: preparedData.metrics,
              Session: {
                /* SessionId is required */
                Id: subSessionId,

                /* StartTimestamp is required */
                StartTimestamp: new Date(subSessionStart).toISOString()
              }
            });

            if (eventName === SESSION_STOP) {
              eventPayload[eventId].Session.Duration = Date.now() - subSessionStart;
              eventPayload[eventId].Session.StopTimestamp = timeStamp;
            }

            return _context3.abrupt("return", eventPayload);

          case 34:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _formatEvent.apply(this, arguments);
}

function callAWS(_x3, _x4) {
  return _callAWS.apply(this, arguments);
}

function _callAWS() {
  _callAWS = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(eventsRequest, config) {
    var pinpointRegion, pinpointEndpoint, pinpointAppId, lambdaArn, lambdaRegion, credentials, getCredentials, debug, creds, aws, lambda_region, pinpoint_region, fips, LAMBDA_FN, PINPOINT_URL, endpointUrl, data, responses;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            pinpointRegion = config.pinpointRegion, pinpointEndpoint = config.pinpointEndpoint, pinpointAppId = config.pinpointAppId, lambdaArn = config.lambdaArn, lambdaRegion = config.lambdaRegion, credentials = config.credentials, getCredentials = config.getCredentials, debug = config.debug;
            creds = credentials;
            /* Use custom creds function */

            if (!(!Object.keys(creds).length && getCredentials)) {
              _context4.next = 12;
              break;
            }

            _context4.prev = 3;
            _context4.next = 6;
            return getCredentials();

          case 6:
            creds = _context4.sent;
            _context4.next = 12;
            break;

          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](3);
            throw new Error(_context4.t0);

          case 12:
            // console.log('credentials', creds)
            aws = new aws4fetch.AwsClient({
              // Support amplify and raw client auth params
              accessKeyId: creds.accessKeyId || creds.AccessKeyId,
              secretAccessKey: creds.secretAccessKey || creds.SecretKey,
              sessionToken: creds.sessionToken || creds.SessionToken,
              retries: 5
            });
            lambda_region = lambdaRegion || pinpointRegion;
            pinpoint_region = pinpointRegion || lambdaRegion;
            fips = config.fips === true ? '-fips' : '';
            LAMBDA_FN = "https://lambda.".concat(lambda_region, ".amazonaws.com/2015-03-31/functions/").concat(lambdaArn, "/invocations");
            PINPOINT_URL = "https://pinpoint".concat(fips, ".").concat(pinpoint_region, ".amazonaws.com/v1/apps/").concat(pinpointAppId, "/events");
            endpointUrl = lambdaArn ? LAMBDA_FN : PINPOINT_URL;
            _context4.next = 21;
            return aws.fetch(endpointUrl, {
              body: JSON.stringify(eventsRequest)
            }).then(function (d) {
              return d.json();
            });

          case 21:
            data = _context4.sent;

            // console.log('pinpoint response', data)
            if (data && data.Results) {
              // Process api responses
              responses = Object.keys(data.Results).map(function (eventId) {
                return data.Results[eventId];
              });
              responses.forEach(function (resp) {
                var EndpointItemResponse = resp.EndpointItemResponse || {};
                var EventsItemResponse = resp.EventsItemResponse || {};

                if (Object.keys(EndpointItemResponse).length) {
                  if (debug) console.log('EndpointItemResponse', EndpointItemResponse);

                  if (ACCEPTED_CODES.includes(EndpointItemResponse.StatusCode)) ; else if (RETRYABLE_CODES.includes(EndpointItemResponse.StatusCode)) ; else {
                    // Try to handle error
                    handleEndpointUpdateBadRequest(EndpointItemResponse, Endpoint);
                  }
                }

                var events = Object.keys(EventsItemResponse);

                if (events.length) {
                  if (debug) console.log('EventsResponse', EventsItemResponse);
                  events.forEach(function (eventId) {// console.log(`[req "${Endpoint.RequestId}"] Event id ${eventId}`, EventsItemResponse[eventId])
                  });
                }
              });
            }

            return _context4.abrupt("return", data);

          case 24:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 9]]);
  }));
  return _callAWS.apply(this, arguments);
}

function handleEndpointUpdateBadRequest(error, endpoint) {
  var StatusCode = error.StatusCode,
      Message = error.Message; // console.log('message', Message)

  if (StatusCode === BAD_REQUEST_CODE) {
    // 400
    if (Message.startsWith('Missing ChannelType')) {
      throw new Error('Missing ChannelType');
    }

    if (Message.startsWith('Exceeded maximum endpoint per user count')) {
      throw new Error('Exceeded maximum endpoint per user count');
    }
  }
}

var migrationRan = false;

function mergeEndpointData() {
  return _mergeEndpointData.apply(this, arguments);
}
/**
 * Array merge function for deepmerge.
 *
 * @param {Array} destinationArray
 * @param {Array} sourceArray
 */


function _mergeEndpointData() {
  _mergeEndpointData = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee5() {
    var endpoint,
        config,
        getUserId,
        getEndpointId,
        getSessionID,
        context,
        id,
        deprecatedData,
        persistedEndpoint,
        pageSession,
        defaultEndpointConfig,
        demographicByClientInfo,
        EndpointData,
        foundId,
        _foundId,
        sessionKey,
        pageKey,
        _args5 = arguments;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            endpoint = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
            config = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
            getUserId = config.getUserId, getEndpointId = config.getEndpointId, getSessionID = config.getSessionID;
            context = grabContext(config);
            _context5.next = 6;
            return getEndpointId();

          case 6:
            id = _context5.sent;

            // @TODO remove in next version
            if (!migrationRan) {
              migrationRan = true; // Backwards compatible endpoint info

              deprecatedData = localStorage.getItem(ENDPOINT_KEY); // clear out old key value

              if (deprecatedData) {
                setEndpoint(id, deprecatedData); // remove old key

                localStorage.removeItem(ENDPOINT_KEY);
              }
            }

            persistedEndpoint = getEndpoint(id);
            pageSession = context.pageSession;
            defaultEndpointConfig = {};
            demographicByClientInfo = {
              AppVersion: clientInfo.appVersion,
              Make: clientInfo.make,
              Model: clientInfo.model,
              ModelVersion: clientInfo.version,
              Platform: clientInfo.platform,
              Locale: clientInfo.language
            };
            EndpointData = {
              Attributes: {},
              Demographic: _objectSpread2({
                AppVersion: clientInfo.appVersion || ''
              }, demographicByClientInfo, {}, defaultEndpointConfig.demographic),
              Location: {},
              Metrics: {}
              /* Add device attributes to endpoint */

            };

            if (clientInfo.device && clientInfo.device.vendor) {
              EndpointData.Attributes.DeviceMake = [clientInfo.device.vendor];
            }

            if (clientInfo.device && clientInfo.device.model) {
              EndpointData.Attributes.DeviceModel = [clientInfo.device.model];
            }

            if (clientInfo.device && clientInfo.device.type) {
              EndpointData.Attributes.DeviceType = [clientInfo.device.type];
            }
            /* Add demographic data to endpoint */


            if (clientInfo.engine && clientInfo.engine.name) {
              EndpointData.Demographic.Make = clientInfo.engine.name;
            }

            if (clientInfo.browser && clientInfo.browser.name) {
              EndpointData.Demographic.Model = clientInfo.browser.name;
            }

            if (clientInfo.browser && clientInfo.browser.version) {
              EndpointData.Demographic.ModelVersion = clientInfo.browser.version;
            }

            if (clientInfo.os && clientInfo.os.name) {
              EndpointData.Demographic.Platform = clientInfo.os.name;
            }

            if (clientInfo.os && clientInfo.os.version) {
              EndpointData.Demographic.PlatformVersion = clientInfo.os.version;
            }
            /*
            if (endpoint.channelType && clientInfo.os.version) {
              EndpointData.ChannelType = endpoint.channelType
            }
            */
            // Merge new endpoint data with defaults.


            endpoint = deepmerge.all([EndpointData, persistedEndpoint, endpoint], {
              // TODO maybe change array merge
              arrayMerge: overwriteMerge
            }); // Sync user ID if it's changed

            if (!(endpoint.User && endpoint.User.UserId)) {
              _context5.next = 27;
              break;
            }

            _context5.next = 25;
            return getUserId();

          case 25:
            foundId = _context5.sent;

            if (endpoint.User.UserId !== foundId) {
              endpoint.User.UserId = foundId;
            }

          case 27:
            if (!(!endpoint.User || !endpoint.User.UserId)) {
              _context5.next = 32;
              break;
            }

            _context5.next = 30;
            return getUserId();

          case 30:
            _foundId = _context5.sent;

            if (_foundId) {
              if (!endpoint.User) endpoint.User = {};
              endpoint.User.UserId = _foundId;
            }

          case 32:
            if (!(endpoint.User && endpoint.User.UserAttributes)) {
              _context5.next = 36;
              break;
            }

            _context5.next = 35;
            return prepareAttributes(endpoint.User.UserAttributes, true);

          case 35:
            endpoint.User.UserAttributes = _context5.sent;

          case 36:
            _context5.next = 38;
            return prepareAttributes(endpoint.Attributes, true);

          case 38:
            endpoint.Attributes = _context5.sent;
            _context5.next = 41;
            return prepareMetrics(endpoint.Metrics);

          case 41:
            endpoint.Metrics = _context5.sent;
            // console.log('endpoint.Metrics', endpoint.Metrics)
            sessionKey = 'sessions';

            if (context.sessionKey) {
              sessionKey = context.sessionKey();
            }

            pageKey = 'pageViews';

            if (context.pageViewKey) {
              pageKey = context.pageViewKey();
            } // Add session and page view counts to endpoint.


            if (!endpoint.Attributes.lastSession) {
              endpoint.Attributes.lastSession = [getSessionID()];
              endpoint.Attributes.lastPageSession = [pageSession];
              endpoint.Metrics[sessionKey] = 1.0;
              endpoint.Metrics[pageKey] = 1.0;
            } else {
              // Increment sessions.
              if (endpoint.Attributes.lastSession[0] !== getSessionID()) {
                endpoint.Attributes.lastSession = [getSessionID()];
                endpoint.Metrics[sessionKey] += 1.0;
              } // Increment pageViews.
              // console.log('[pageViews] lastPageSession', endpoint.Attributes.lastPageSession[0])
              // console.log('[pageViews] pageSession', pageSession)


              if (endpoint.Attributes.lastPageSession[0] !== pageSession) {
                endpoint.Attributes.lastPageSession = [pageSession];
                endpoint.Metrics[pageKey] += 1.0; // console.log('[pageViews] Its different increment page views. New Count', endpoint.Metrics[pageKey])
              }
            } // Store the endpoint data.


            setEndpoint(id, endpoint);
            return _context5.abrupt("return", endpoint);

          case 49:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _mergeEndpointData.apply(this, arguments);
}

function overwriteMerge(_destinationArray, sourceArray) {
  return sourceArray;
}

function grabContext(config) {
  if (typeof config.getContext === 'function') {
    return config.getContext();
  }

  return config.getContext;
}
/**
 * Resolves an attribute or metric value and sanitize it.
 *
 * @param {mixed} value
 * @param {Function} sanitizeCallback
 */


function prepareData(_x5, _x6) {
  return _prepareData.apply(this, arguments);
}
/**
 * Ensure value is a string or array of strings.
 *
 * @param {mixed} value
 */


function _prepareData() {
  _prepareData = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee6(value, sanitizeCallback) {
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(typeof value === 'function')) {
              _context6.next = 4;
              break;
            }

            _context6.next = 3;
            return value();

          case 3:
            value = _context6.sent;

          case 4:
            return _context6.abrupt("return", sanitizeCallback(value));

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _prepareData.apply(this, arguments);
}

function sanitizeAttribute(value) {
  return Array.isArray(value) ? value.map(function (val) {
    return val.toString();
  }) : value.toString();
}
/**
 * Prepares an object for inclusion in endpoint data or event data.
 *
 * @param {Object} attributes
 * @param {Boolean} asArray If true ensure an array of strings is returned for each property
 */


function prepareAttributes(_x7) {
  return _prepareAttributes.apply(this, arguments);
}
/**
 * Ensure value is a single float.
 *
 * @param {mixed} value
 */

function _prepareAttributes() {
  _prepareAttributes = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee7(attributes) {
    var asArray,
        sanitized,
        name,
        value,
        _args7 = arguments;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            asArray = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;
            sanitized = {};
            _context7.t0 = regeneratorRuntime.keys(attributes);

          case 3:
            if ((_context7.t1 = _context7.t0()).done) {
              _context7.next = 17;
              break;
            }

            name = _context7.t1.value;
            value = Array.isArray(attributes[name]) ? attributes[name] : [attributes[name]];

            if (!asArray) {
              _context7.next = 12;
              break;
            }

            _context7.next = 9;
            return prepareData(value, sanitizeAttribute);

          case 9:
            sanitized[name] = _context7.sent;
            _context7.next = 15;
            break;

          case 12:
            _context7.next = 14;
            return prepareData(value[0], sanitizeAttribute);

          case 14:
            sanitized[name] = _context7.sent;

          case 15:
            _context7.next = 3;
            break;

          case 17:
            return _context7.abrupt("return", sanitized);

          case 18:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _prepareAttributes.apply(this, arguments);
}

function sanitizeMetric(value) {
  return parseFloat(Number(Array.isArray(value) ? value[0] : value));
}
/**
 * Prepares an object for inclusion in endpoint data or event data.
 *
 * @param {Object} metrics
 */


function prepareMetrics(_x8) {
  return _prepareMetrics.apply(this, arguments);
}
/* TODO wire up beacon
function sendBeaconRequest() {
	const eventParams = this._generateBatchItemContext(params);

	const { region } = this._config;
	const { ApplicationId, EventsRequest } = eventParams;

	const accessInfo = {
		secret_key: this._config.credentials.secretAccessKey,
		access_key: this._config.credentials.accessKeyId,
		session_token: this._config.credentials.sessionToken,
	};

	const url = `https://pinpoint.${region}.amazonaws.com/v1/apps/${ApplicationId}/events/legacy`;
	const body = JSON.stringify(EventsRequest);
	const method = 'POST';

	const request = {
		url,
		body,
		method,
	};

	const serviceInfo = { region, service: MOBILE_SERVICE_NAME };

	const requestUrl = Signer.signUrl(
		request,
		accessInfo,
		serviceInfo,
		null
	);

	const success = navigator.sendBeacon(requestUrl, body);

	if (success) {
		return console.log('sendBeacon success');
	}
	return console.log('sendBeacon failure');
}
*/

/* usage
updateEndpoint({
  "Address": 'test@gmail.com',
  "Attributes": { "lol": ['thing'], baz: 'bar' },
  "Demographic": {
    "AppVersion": string,
    "Locale": string,
    "Make": string,
    "Model": string,
    "ModelVersion": string,
    "Platform": string,
    "PlatformVersion": string,
    "Timezone": string
  },
  "Location": {
    "City": string,
    "Country": string,
    "Latitude": number,
    "Longitude": number,
    "PostalCode": string,
    "Region": string
  },
  "Metrics": { "key": 1 },
  "OptOut": 'NONE',
  "User": {
    "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
    "UserId": 'user-123'
  }
})

updateEndpoint({
  "Address": 'jimbo@gmail.com',
  "Attributes": { "lol": ['thing'], baz: 'bar' },
  "Metrics": { "key": 1 },
  "OptOut": 'NONE',
  "User": {
    "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
    "UserId": 'user-xyz'
  }
})
*/

function _prepareMetrics() {
  _prepareMetrics = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee8(metrics) {
    var sanitized, name;
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            sanitized = {};
            _context8.t0 = regeneratorRuntime.keys(metrics);

          case 2:
            if ((_context8.t1 = _context8.t0()).done) {
              _context8.next = 9;
              break;
            }

            name = _context8.t1.value;
            _context8.next = 6;
            return prepareData(metrics[name], sanitizeMetric);

          case 6:
            sanitized[name] = _context8.sent;
            _context8.next = 2;
            break;

          case 9:
            return _context8.abrupt("return", sanitized);

          case 10:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _prepareMetrics.apply(this, arguments);
}

function isSessionStorageSupported() {
  if (!inBrowser) return false;
  var sessionStorage = window.sessionStorage;

  try {
    sessionStorage.setItem('__test', 'x');
    sessionStorage.removeItem('__test');
    return true;
  } catch (e) {
    return false;
  }
}

var hasSessionStorage = isSessionStorageSupported();

var config = {
  /* Disable anonymous MTU */
  disableAnonymousTraffic: false,
  // Pinpoint service region
  pinpointRegion: 'us-east-1',
  // Custom event mapping
  eventMapping: {}
  /**
   * AWS Pinpoint analytics integration
   * @link https://docs.aws.amazon.com/pinpoint/latest/developerguide/
   * @param {object} pluginConfig - Plugin settings
   * @param {string} pluginConfig.pinpointAppId - AWS Pinpoint app Id for client side tracking
   * @param {function} pluginConfig.getCredentials - Async function to get AWS Cognito creds 
   * @param {string} [pluginConfig.pinpointRegion] - AWS Pinpoint region. Defaults to us-east-1
   * @param {string} [pluginConfig.appTitle] - The title of the app that's recording the event.
   * @param {string} [pluginConfig.appPackageName] - The name of the app package, such as com.example.my_app.
   * @param {string} [pluginConfig.appVersionCode] - The version number of the app, such as 3.2.0
   * @param {string} [pluginConfig.fips] - Use the AWS FIPS service endpoint for Pinpoint
   * @param {boolean} [pluginConfig.disableAnonymousTraffic] -  Disable anonymous events from firing
   * @return {object} Analytics plugin
   * @example
   *
   * awsPinpointPlugin({
   *   pinpointAppId: '938bebb1ae954e123133213160f2b3be4',
   *   getCredentials: () => Auth.currentCredentials(),
   * })
   */

};

function awsPinpointPlugin() {
  var pluginConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var recordEvent;
  var updateEndpoint;
  var tabListener;
  var elapsedSessionTime = 0;
  /* Page-session (on route changes) */

  var pageSession = analyticsUtils.uuid();
  /* Sub-session (visibility changes) */

  var subSessionId = analyticsUtils.uuid();
  var subSessionStart = Date.now(); // let scrollDepthMax = 0
  // let scrollDepthNow = 0

  return {
    name: 'aws-pinpoint',
    config: _objectSpread2({}, config, {}, pluginConfig),
    bootstrap: function bootstrap(pluginApi) {
      var config = pluginApi.config,
          instance = pluginApi.instance;
      /* Load aws-pinpoint script after userId exists */

      if (config.disableAnonymousTraffic && !instance.user('userId')) {
        instance.once('identifyStart', function (_ref) {
          var plugins = _ref.plugins;
          var self = plugins['aws-pinpoint'];

          if (!self.loaded()) {
            instance.loadPlugin('aws-pinpoint');
          }
        });
      }
    },
    initialize: function initialize$$1(_ref2) {
      var config = _ref2.config,
          instance = _ref2.instance;
      var disableAnonymousTraffic = config.disableAnonymousTraffic;
      /* Disable pinpoint if user is not yet identified. */

      var state = instance.getState();
      var userID = (state.user || {}).userId;
      var context = state.context || {};
      var app = context.app,
          version = context.version;

      if (!userID && disableAnonymousTraffic) {
        return false;
      }
      /* Initialize pinpoint client */


      var pinpointClient = initialize(_objectSpread2({}, config, {
        // The title of the app that's recording the event.
        appTitle: config.appTitle || app,
        // The package name of the app that's recording the event.
        appPackageName: config.appPackageName || app,
        // The version number of the app that's recording the event.
        appVersionCode: config.appVersionCode || version,
        // Get pinpoint endpoint ID
        getEndpointId: function getEndpointId() {
          return instance.user('anonymousId');
        },
        getUserId: function getUserId() {
          return instance.user('userId');
        },
        getSessionID: getSessionID,
        getContext: function getContext() {
          return {
            elapsed: elapsedSessionTime,
            pageSession: pageSession,
            subSessionId: subSessionId,
            subSessionStart: subSessionStart,
            sessionKey: config.sessionKey,
            pageViewKey: config.pageViewKey // scrollDepth: scrollDepthNow,
            // scrollDepthMax

          };
        },
        enrichEventAttributes: function enrichEventAttributes() {
          return {
            hash: window.location.hash,
            path: window.location.pathname,
            referrer: document.referrer,
            search: window.location.search,
            title: document.title,
            host: window.location.hostname,
            url: window.location.origin + window.location.pathname
          };
        },
        // Pass scroll into with all events
        enrichEventMetrics: function enrichEventMetrics() {
          return {};
          /*
          return {
            // scrollDepth: scrollDepthNow,
            // scrollDepthMax
          }
          */
        },
        // Custom event mapping
        eventMapping: config.eventMapping
      }));

      recordEvent = pinpointClient.recordEvent;
      updateEndpoint = pinpointClient.updateEndpoint;
      /* Start session */

      recordEvent(SESSION_START);
      /* Scroll tracking
      function pageScrolled(data) {
        const { trigger, direction, scrollMax, scrollMin, range } = data
        // Set current scroll values 
        scrollDepthNow = trigger
        scrollDepthMax = scrollMax
        // Record page scroll event 
        recordEvent('pageScrolled')
      }
       const detachScrollListener = onScrollChange({
        // 25: pageScrolled,
        50: pageScrolled,
        75: pageScrolled,
        90: pageScrolled
      })
      */

      tabListener = analyticsPluginTabEvents.onTabChange(function (isHidden) {
        // console.log('isHidden', isHidden)
        if (isHidden) {
          // On hide increment elapsed time.
          elapsedSessionTime += Date.now() - subSessionStart; // Fire session stop event.

          recordEvent(SESSION_STOP, false);
        } else {
          // Reset subSessions.
          subSessionId = analyticsUtils.uuid();
          subSessionStart = Date.now(); // Fire session start event.

          recordEvent(SESSION_START);
        }
      });
    },
    page: function page(_ref3) {
      var payload = _ref3.payload,
          config = _ref3.config;

      if (!recordEvent) {
        console.log('Pinpoint not loaded');
        return;
      } // Fire page view and update pageSession Id


      var queuePageView = true;
      recordEvent(PAGE_VIEW, queuePageView).then(function () {
        pageSession = analyticsUtils.uuid();
      });
    },
    reset: function reset(_ref4) {
      var instance = _ref4.instance;
      var id = instance.user('anonymousId');
      var key = getStorageKey(id);
      storage.removeItem(key);
    },
    track: function track(_ref5) {
      var payload = _ref5.payload,
          config = _ref5.config,
          instance = _ref5.instance;

      if (!recordEvent) {
        console.log('Pinpoint not loaded');
        return;
      }

      if (config.disableAnonymousTraffic && !payload.userId) {
        return;
      }

      var data = formatEventData(payload.properties);
      recordEvent(payload.event, data);
    },
    identify: function identify(_ref6) {
      var payload = _ref6.payload;
      var userId = payload.userId,
          traits = payload.traits;

      if (!updateEndpoint) {
        console.log('Pinpoint not loaded');
        return;
      }

      var userInfo = {};

      if (userId) {
        userInfo.UserId = userId;
      }

      if (traits && Object.keys(traits).length) {
        userInfo.UserAttributes = traits;
      } // Update endpoint in AWS pinpoint


      updateEndpoint(_objectSpread2({}, traits.email ? {
        Address: traits.email,
        ChannelType: CHANNEL_TYPES.EMAIL
      } : {}, {}, !Object.keys(userInfo).length ? {} : {
        User: userInfo
      }));
      /* example
      updateEndpoint({
        "Address": 'jimbo@gmail.com',
        "Attributes": { "lol": ['thing'], baz: 'bar' },
        "Metrics": { "key": 1 },
        "OptOut": 'NONE',
        "User": {
          "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
          "UserId": 'user-xyz'
        }
      })
      */
    },
    loaded: function loaded() {
      return !!recordEvent;
    }
  };
}

function formatEventData(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    var value = obj[key];

    if (typeof value === 'number') {
      acc.metrics[key] = value;
    }

    if (typeof value === 'string' || typeof value === 'boolean') {
      acc.attributes[key] = value;
    }

    return acc;
  }, {
    attributes: {},
    metrics: {}
  });
}

var SESSION_KEY = '__session_id';
var tempStorageFallback = {};

function getSessionID() {
  if (!hasSessionStorage) {
    var windowSession = tempStorageFallback[SESSION_KEY];
    if (windowSession) return windowSession;

    var _sessionID = analyticsUtils.uuid();

    tempStorageFallback[SESSION_KEY] = _sessionID;
    return _sessionID;
  } // Get stored session.


  var sessionID = window.sessionStorage.getItem(SESSION_KEY);

  if (sessionID) {
    return sessionID;
  } // Create and set a UUID.


  var newSessionID = analyticsUtils.uuid();
  window.sessionStorage.setItem(SESSION_KEY, newSessionID);
  return newSessionID;
}

/* This module will shake out unused code + work in browser and node 🎉 */

var index = awsPinpointPlugin;

exports.default = index;
exports.PINPOINT_EVENTS = events;
exports.formatEvent = formatEvent;
