import 'deepmerge';
import { uuid } from 'analytics-utils';
import 'aws4fetch';
import 'analytics-plugin-tab-events';

function awsPinpointNode(pluginConfig) {
  return {
    name: 'aws-pinpoint',
    initialize: function initialize(_ref) {
      var config = _ref.config;
      console.log('AWS pinpoint has no server implementation');
    }
  };
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function browserClientInfo() {
  if (typeof window === 'undefined') {
    return {};
  }

  if (!window.navigator) {
    return {};
  }

  var _window$navigator = window.navigator,
      platform = _window$navigator.platform,
      product = _window$navigator.product,
      vendor = _window$navigator.vendor,
      userAgent = _window$navigator.userAgent;
  var type = browserType(userAgent);
  return {
    platform: platform,
    make: vendor || product,
    model: type.type,
    version: type.version,
    appVersion: [type.type, type.version].join('/'),
    language: getLanguage(),
    timezone: browserTimezone()
  };
}

function getLanguage() {
  var _window$navigator2 = window.navigator,
      language = _window$navigator2.language,
      browserLanguage = _window$navigator2.browserLanguage,
      languages = _window$navigator2.languages;
  return (language || browserLanguage || (languages || ['en_US'])[0]).toLowerCase().replace('-', '_');
}

function browserTimezone() {
  var tzMatch = /\(([A-Za-z\s].*)\)/.exec(new Date().toString());
  return tzMatch ? tzMatch[1] || '' : '';
}

function browserType(userAgent) {
  var operaMatch = /.+(Opera[\s[A-Z]*|OPR[\sA-Z]*)\/([0-9\.]+).*/i.exec(userAgent);

  if (operaMatch) {
    return {
      type: operaMatch[1],
      version: operaMatch[2]
    };
  }

  var ieMatch = /.+(Trident|Edge)\/([0-9\.]+).*/i.exec(userAgent);

  if (ieMatch) {
    return {
      type: ieMatch[1],
      version: ieMatch[2]
    };
  }

  var cfMatch = /.+(Chrome|Firefox|FxiOS)\/([0-9\.]+).*/i.exec(userAgent);

  if (cfMatch) {
    return {
      type: cfMatch[1],
      version: cfMatch[2]
    };
  }

  var sMatch = /.+(Safari)\/([0-9\.]+).*/i.exec(userAgent);

  if (sMatch) {
    return {
      type: sMatch[1],
      version: sMatch[2]
    };
  }

  var awkMatch = /.+(AppleWebKit)\/([0-9\.]+).*/i.exec(userAgent);

  if (awkMatch) {
    return {
      type: awkMatch[1],
      version: awkMatch[2]
    };
  }

  var anyMatch = /.*([A-Z]+)\/([0-9\.]+).*/i.exec(userAgent);

  if (anyMatch) {
    return {
      type: anyMatch[1],
      version: anyMatch[2]
    };
  }

  return {
    type: '',
    version: ''
  };
}

function getEventName(key) {
  var eventMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return eventMap[key] || key;
}

var ALLOWED_CHANNELS = ['PUSH', 'GCM', 'APNS', 'APNS_SANDBOX', 'APNS_VOIP', 'APNS_VOIP_SANDBOX', 'ADM', 'SMS', 'VOICE', 'EMAIL', 'BAIDU', 'CUSTOM'];
var CHANNEL_TYPES = ALLOWED_CHANNELS.reduce(function (acc, curr) {
  acc[curr] = curr;
  return acc;
}, {});

/* The endpoint began a new session. */
var SESSION_START = '_session.start';
/* The endpoint ended a session. */

var SESSION_STOP = '_session.stop';
/* The endpoint paused a session. Paused sessions can be resumed so that you can continue to collect metrics without starting an entirely new session. */

var SESSION_PAUSE = '_session.pause';
/* The endpoint resumed a session. */

var SESSION_RESUME = '_session.resume';
/* The endpoint logged in to your app. */

var AUTH_SIGN_IN = '_userauth.sign_in';
/* A new endpoint completed the registration process in your app. */

var AUTH_SIGN_UP = '_userauth.sign_up';
/* The endpoint attempted to sign in to your app, but wasn't able to complete the process. */

var AUTH_FAIL = '_userauth.auth_fail';
/* The endpoint made a purchase in your app. */

var ECOM_PURCHASE = '_monetization.purchase';
/* The pageview event */

var PAGE_VIEW = 'pageView';

var events = /*#__PURE__*/Object.freeze({
  SESSION_START: SESSION_START,
  SESSION_STOP: SESSION_STOP,
  SESSION_PAUSE: SESSION_PAUSE,
  SESSION_RESUME: SESSION_RESUME,
  AUTH_SIGN_IN: AUTH_SIGN_IN,
  AUTH_SIGN_UP: AUTH_SIGN_UP,
  AUTH_FAIL: AUTH_FAIL,
  ECOM_PURCHASE: ECOM_PURCHASE,
  PAGE_VIEW: PAGE_VIEW
});

var inBrowser = typeof window !== 'undefined';

// import 'navigator.sendbeacon'

var BEACON_SUPPORTED = typeof navigator !== 'undefined' && navigator && typeof navigator.sendBeacon === 'function';
var clientInfo = browserClientInfo(); // TODO localize queue

function formatEvent(_x2) {
  return _formatEvent.apply(this, arguments);
}

function _formatEvent() {
  _formatEvent = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3(eventName) {
    var data,
        config,
        appTitle,
        appPackageName,
        appVersionCode,
        eventMapping,
        getSessionID,
        enrichEventAttributes,
        enrichEventMetrics,
        debug,
        type,
        contextInfo,
        pageSession,
        subSessionId,
        subSessionStart,
        elapsed,
        userDefinedAttributes,
        eventId,
        time,
        timeStamp,
        sessionId,
        defaultEventAttributes,
        extraAttributes,
        eventAttributes,
        elapsedSessionTime,
        userDefinedMetrics,
        defaultMetrics,
        extraMetrics,
        eventMetrics,
        preparedData,
        eventPayload,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            data = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
            config = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
            appTitle = config.appTitle, appPackageName = config.appPackageName, appVersionCode = config.appVersionCode, eventMapping = config.eventMapping, getSessionID = config.getSessionID, enrichEventAttributes = config.enrichEventAttributes, enrichEventMetrics = config.enrichEventMetrics, debug = config.debug;
            type = getEventName(eventName, eventMapping);
            contextInfo = grabContext(config); // console.log('contextInfo', contextInfo)

            pageSession = contextInfo.pageSession, subSessionId = contextInfo.subSessionId, subSessionStart = contextInfo.subSessionStart, elapsed = contextInfo.elapsed;
            userDefinedAttributes = data.attributes || {};
            eventId = data.eventId || uuid();
            time = data.time ? new Date(data.time) : new Date();
            timeStamp = time.toISOString();
            sessionId = data.sessionId || getSessionID();
            defaultEventAttributes = {
              date: timeStamp,
              session: sessionId,
              pageSession: pageSession
            };
            _context3.next = 14;
            return enrichEventAttributes();

          case 14:
            extraAttributes = _context3.sent;

            /* Format attributes */
            eventAttributes = _objectSpread2({}, defaultEventAttributes, {}, extraAttributes, {}, userDefinedAttributes);
            /* Format metrics */

            elapsedSessionTime = elapsed + (time.getTime() - subSessionStart);
            userDefinedMetrics = data.metrics || {};
            defaultMetrics = {
              /* Time of session */
              sessionTime: elapsedSessionTime,

              /* Date metrics */
              hour: time.getHours(),
              day: time.getDay() + 1,
              month: time.getMonth() + 1,
              year: time.getFullYear()
            };
            _context3.next = 21;
            return enrichEventMetrics();

          case 21:
            extraMetrics = _context3.sent;
            eventMetrics = _objectSpread2({}, defaultMetrics, {}, extraMetrics, {}, userDefinedMetrics);
            _context3.next = 25;
            return prepareAttributes(eventAttributes);

          case 25:
            _context3.t0 = _context3.sent;
            _context3.next = 28;
            return prepareMetrics(eventMetrics);

          case 28:
            _context3.t1 = _context3.sent;
            preparedData = {
              attributes: _context3.t0,
              metrics: _context3.t1
            };

            if (debug) {
              console.log("".concat(eventId, ":").concat(type));
              console.log('eventAttributes', preparedData.attributes);
              console.log('eventMetrics', preparedData.metrics);
            } // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Pinpoint.html#putEvents-property


            eventPayload = _defineProperty({}, eventId, {
              EventType: type,
              Timestamp: timeStamp,
              AppPackageName: appPackageName,
              AppTitle: appTitle,
              AppVersionCode: appVersionCode,

              /* Event attributes */
              Attributes: preparedData.attributes,

              /* Event metrics */
              Metrics: preparedData.metrics,
              Session: {
                /* SessionId is required */
                Id: subSessionId,

                /* StartTimestamp is required */
                StartTimestamp: new Date(subSessionStart).toISOString()
              }
            });

            if (eventName === SESSION_STOP) {
              eventPayload[eventId].Session.Duration = Date.now() - subSessionStart;
              eventPayload[eventId].Session.StopTimestamp = timeStamp;
            }

            return _context3.abrupt("return", eventPayload);

          case 34:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _formatEvent.apply(this, arguments);
}

function grabContext(config) {
  if (typeof config.getContext === 'function') {
    return config.getContext();
  }

  return config.getContext;
}
/**
 * Resolves an attribute or metric value and sanitize it.
 *
 * @param {mixed} value
 * @param {Function} sanitizeCallback
 */


function prepareData(_x5, _x6) {
  return _prepareData.apply(this, arguments);
}
/**
 * Ensure value is a string or array of strings.
 *
 * @param {mixed} value
 */


function _prepareData() {
  _prepareData = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee6(value, sanitizeCallback) {
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(typeof value === 'function')) {
              _context6.next = 4;
              break;
            }

            _context6.next = 3;
            return value();

          case 3:
            value = _context6.sent;

          case 4:
            return _context6.abrupt("return", sanitizeCallback(value));

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _prepareData.apply(this, arguments);
}

function sanitizeAttribute(value) {
  return Array.isArray(value) ? value.map(function (val) {
    return val.toString();
  }) : value.toString();
}
/**
 * Prepares an object for inclusion in endpoint data or event data.
 *
 * @param {Object} attributes
 * @param {Boolean} asArray If true ensure an array of strings is returned for each property
 */


function prepareAttributes(_x7) {
  return _prepareAttributes.apply(this, arguments);
}
/**
 * Ensure value is a single float.
 *
 * @param {mixed} value
 */

function _prepareAttributes() {
  _prepareAttributes = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee7(attributes) {
    var asArray,
        sanitized,
        name,
        value,
        _args7 = arguments;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            asArray = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;
            sanitized = {};
            _context7.t0 = regeneratorRuntime.keys(attributes);

          case 3:
            if ((_context7.t1 = _context7.t0()).done) {
              _context7.next = 17;
              break;
            }

            name = _context7.t1.value;
            value = Array.isArray(attributes[name]) ? attributes[name] : [attributes[name]];

            if (!asArray) {
              _context7.next = 12;
              break;
            }

            _context7.next = 9;
            return prepareData(value, sanitizeAttribute);

          case 9:
            sanitized[name] = _context7.sent;
            _context7.next = 15;
            break;

          case 12:
            _context7.next = 14;
            return prepareData(value[0], sanitizeAttribute);

          case 14:
            sanitized[name] = _context7.sent;

          case 15:
            _context7.next = 3;
            break;

          case 17:
            return _context7.abrupt("return", sanitized);

          case 18:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));
  return _prepareAttributes.apply(this, arguments);
}

function sanitizeMetric(value) {
  return parseFloat(Number(Array.isArray(value) ? value[0] : value));
}
/**
 * Prepares an object for inclusion in endpoint data or event data.
 *
 * @param {Object} metrics
 */


function prepareMetrics(_x8) {
  return _prepareMetrics.apply(this, arguments);
}
/* TODO wire up beacon
function sendBeaconRequest() {
	const eventParams = this._generateBatchItemContext(params);

	const { region } = this._config;
	const { ApplicationId, EventsRequest } = eventParams;

	const accessInfo = {
		secret_key: this._config.credentials.secretAccessKey,
		access_key: this._config.credentials.accessKeyId,
		session_token: this._config.credentials.sessionToken,
	};

	const url = `https://pinpoint.${region}.amazonaws.com/v1/apps/${ApplicationId}/events/legacy`;
	const body = JSON.stringify(EventsRequest);
	const method = 'POST';

	const request = {
		url,
		body,
		method,
	};

	const serviceInfo = { region, service: MOBILE_SERVICE_NAME };

	const requestUrl = Signer.signUrl(
		request,
		accessInfo,
		serviceInfo,
		null
	);

	const success = navigator.sendBeacon(requestUrl, body);

	if (success) {
		return console.log('sendBeacon success');
	}
	return console.log('sendBeacon failure');
}
*/

/* usage
updateEndpoint({
  "Address": 'test@gmail.com',
  "Attributes": { "lol": ['thing'], baz: 'bar' },
  "Demographic": {
    "AppVersion": string,
    "Locale": string,
    "Make": string,
    "Model": string,
    "ModelVersion": string,
    "Platform": string,
    "PlatformVersion": string,
    "Timezone": string
  },
  "Location": {
    "City": string,
    "Country": string,
    "Latitude": number,
    "Longitude": number,
    "PostalCode": string,
    "Region": string
  },
  "Metrics": { "key": 1 },
  "OptOut": 'NONE',
  "User": {
    "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
    "UserId": 'user-123'
  }
})

updateEndpoint({
  "Address": 'jimbo@gmail.com',
  "Attributes": { "lol": ['thing'], baz: 'bar' },
  "Metrics": { "key": 1 },
  "OptOut": 'NONE',
  "User": {
    "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
    "UserId": 'user-xyz'
  }
})
*/

function _prepareMetrics() {
  _prepareMetrics = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee8(metrics) {
    var sanitized, name;
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            sanitized = {};
            _context8.t0 = regeneratorRuntime.keys(metrics);

          case 2:
            if ((_context8.t1 = _context8.t0()).done) {
              _context8.next = 9;
              break;
            }

            name = _context8.t1.value;
            _context8.next = 6;
            return prepareData(metrics[name], sanitizeMetric);

          case 6:
            sanitized[name] = _context8.sent;
            _context8.next = 2;
            break;

          case 9:
            return _context8.abrupt("return", sanitized);

          case 10:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _prepareMetrics.apply(this, arguments);
}

function isSessionStorageSupported() {
  if (!inBrowser) return false;
  var sessionStorage = window.sessionStorage;

  try {
    sessionStorage.setItem('__test', 'x');
    sessionStorage.removeItem('__test');
    return true;
  } catch (e) {
    return false;
  }
}

var hasSessionStorage = isSessionStorageSupported();

/* This module will shake out unused code + work in browser and node 🎉 */

var index = awsPinpointNode;

export default index;
export { events as PINPOINT_EVENTS, formatEvent };
